{
    "collab_server" : "",
    "contents" : "identify_bouts <- function(datadir, out_file, n_col = 12, return_df = F){\n  \n  #install packages if not installed\n  #load packages\n  if (!require(tidyverse)) install.packages('tidyverse')\n  library(tidyverse)\n  \n  if(!require(lubridate)) intall.packages('lubridate')\n  library(lubridate)\n\n#get list of csv file names\n  csvfnames <- list.files(path = datadir, pattern = \"*.csv\", recursive = TRUE, full.names = TRUE)\n  \n  all_bouts_df <- tibble(\"Sum_Duration\" = NA,\n                         \"idno\" = NA,\n                         \"Date\" = NA)\n  \n  bouts_person_df <- tibble(\"idno\" = NA,\n                            \"N_Bouts\" = NA,\n                            \"Rows\" = NA,\n                            \"Wear_Time_Seconds\" = NA,\n                            \"Wear_Time_HMS\" = as.period(NA),\n                            \"Run_Time\" = NA,\n                            \"Valid_Days\" = NA,\n                            \"flag\" = NA)\n  \n  # for(i in 1:length(csvfnames)){\n  for(i in 1:length(csvfnames)){\n    \n    #print the row number for debugging\n    print(i)\n   \n    time1 <- Sys.time()\n  \n  #read in one file and identify walk bouts\n    data1 <- read_csv(csvfnames[i], skip = 10)\n    \n    #identify epoch length from meta data (line 5 of standard output format)\n    data1_epoch <- read_csv(csvfnames[i], skip = 4, n_max = 1, col_names = \"epoch\") %>%\n      pull(epoch) %>%\n      str_sub(start = 25, end = 32) %>%\n      hms() %>%\n      as.numeric()\n    \n    \n    \n    \n    #pull idno from filename\n    id <- str_sub(csvfnames[i], 100, 105)\n    \n    # bouts_person_df$idno[i] <- id\n    \n    #flag if the number of columns is different than expected\n    if(ncol(data1) != n_col) {warning(paste0(\"Participant \", id, \", row \", i, \" data format unexpected; record dropped\"))} \n    \n    #only execute code if proper number of columns\n    #using two if statements rather than if...else due to the latter being finicky\n    if(ncol(data1) == n_col){\n    \n    #1. Collapse to 30 second epochs\n    \n    #a. Create lead variable and sum current row and lead cpe to create running 30 second total\n    \n        if(data1_epoch == 15){\n        \n          data1 <- data1 %>%\n          mutate(\"lead_Axis1\" = lead(Axis1),\n                 \"Axis1_totl30\" = Axis1 + lead_Axis1)\n          \n        }\n          \n        if(data1_epoch == 10){\n          \n          data1 <- data1 %>%\n            mutate(\"lead1_Axis1\" = lead(Axis1),\n                   \"lead2_Axis1\" = lead(Axis1, n = 2),\n                   \"Axis1_totl30\" = Axis1 + lead1_Axis1 + lead2_Axis1)\n          \n        }  \n    \n    #check\n    # min_ind <- min(which(data1$Axis1 > 0))\n    \n    \n    # *Check*\n      \n    # \n    # data1 %>%\n    #   select(Time, Axis1, lead_Axis1, Axis1_totl30) %>%\n    #   slice(min_ind, min_ind+1)\n    \n    \n    #b. Subset to keep only rows whose time is a multiple of 30 seconds\n    \n    #create seconds variable\n    data1 <- data1 %>%\n      mutate(\"time_sec\" = as.duration(Time)) %>%\n      filter(as.numeric(time_sec)%%30 == 0) #keep only rows where time is multiple of 30s\n    \n    #create threshold indicator for counts/30s epoch > 500\n    data1 <- data1 %>%\n      mutate(\"ovr500\" = Axis1_totl30 > 500)\n    \n    \n    #2. Remove blocks of zeros >= 20 minutes\n    \n    #a. categorize as Active/Non_Active based on Axis1  > 0\n    data1 <- data1 %>%\n      mutate(\"Active\" = case_when(Axis1_totl30 > 0 ~ \"Active\",\n                                  Axis1_totl30 == 0 ~ \"Non_Active\") %>% factor())\n    \n    \n    #b. Run length encoding on clusters of activity/inactivity\n    \n    rle_active <- rle(as.numeric(data1$Active))\n    \n    #c. Convert output of rle to data frame to use to create indices for subsetting data\n    \n    # *Cumulative sum of run lengths (from run length encoding) gives the index of the end of each run. The index for the beginning of each run can be found by the end of the previous run plus 1*\n      \n    #convert rle output to data frame\n    rle_df <- tibble(\"values\" = rle_active$values,\n                     \"Active\" = factor(values,\n                                       labels = c(\"Active\", \"Inactive\")),\n                     \"lengths\" = rle_active$lengths,\n                     \"cumul_lgth\" = cumsum(lengths),\n                     #replace NA with 1 as only NA will be in row 1 since no previous row for lag function\n                     \"begin\" = replace_na(lag(cumul_lgth) + 1, replace = 1),\n                     \"end\" = cumul_lgth,\n                     \"duration\" = end - begin + 1)\n    \n    #d. Create a vector of rows than meet the criteria to be removed (inactive run length of over 40 rows/20 minutes)\n    indices <- rle_df %>%\n      filter(values == 2 & duration > 40) %>%\n      select(begin, end)\n    \n      \n      \n    #e. Loop through rle data frame to fill a vector of values to remove defined by the beginning and end index of each row\n    to_remove <- NULL\n    \n    for(q in 1:length(indices$begin)){\n      beg_ <- indices$begin[q]\n      end_ <- indices$end[q]\n      values_ <- beg_:end_\n      # print(values_)\n      to_remove <- c(to_remove, values_)\n    }\n    \n    data1$remove_20min <- \"Keep\"\n    data1$remove_20min[to_remove] <- \"Remove\"\n    \n    #f. create subset data frame after removing inactive periods\n    data2 <-  data1 %>%\n      filter(remove_20min == \"Keep\")\n    \n    #g. Keep only days with at least 8hr of wear time after removing 20 min runs of inactivity\n    \n    #create count of (valid) epochs/rows per day\n    date_counts <- data2 %>%\n      group_by(Date) %>%\n      tally()\n    \n    #further subset by days with >= 960 rows (8 hours)\n    valid_dates <- date_counts %>%\n      filter(n >= 960)\n    \n    #subset data frame by valid dates (>= 8hrs of activity)\n    data3 <- data2 %>%\n      filter(Date %in% valid_dates$Date)\n    \n    \n    \n    \n    ###Use rle to identify runs of activity >= 500 cpe threshold\n    \n    #identify bouts based on five minute consecutive epochs >= 500 cpe\n    rle_over500 <- rle(data3$ovr500)\n    rle_over500$values[rle_over500$values == \"TRUE\"] <- \"Walking\"\n    rle_over500$values[rle_over500$values == \"FALSE\"] <- \"No_Walk\"\n    \n    #only run rest of code if there is at least 1 run of physical activity (>= 500cpe)\n    # rle values > 1 because first entry will be nonactivity (\"No_Walk\"); > 1 requires at least 1 entry of \"Walking\"\n    if(length(rle_over500$values) > 1){\n    \n    #Create data frame from output of rle, include cumulative sum (length), and beginning/end row index of each run\n    rle_dfbouts <- tibble(\"Value\" = rle_over500$values,\n                          \"Length\" = rle_over500$lengths,\n                          \"cumul_lgth\" = cumsum(Length),\n                          \"begin\" = replace_na(lag(cumul_lgth) + 1, replace = 1),\n                          \"end\" = cumul_lgth)\n    \n    # Identify bouts by time rather than consecutive rows\n    rle_dfbouts$Date <- data3$Date[rle_dfbouts$begin]\n    rle_dfbouts$Time_begin <- data3$Time[rle_dfbouts$begin]\n    rle_dfbouts$Time_end <- data3$Time[rle_dfbouts$end]\n    rle_dfbouts$Duration <- (rle_dfbouts$Time_end - rle_dfbouts$Time_begin + 30)\n    rle_dfbouts$lag_end <- lag(rle_dfbouts$Time_end)\n    \n    \n    rle_walkbouts <- rle_dfbouts %>%\n      filter(Value == \"Walking\") %>%\n      mutate(\"lag_end\" = lag(Time_end),\n             \"Downtime_before\" = Time_begin - lag_end + 30,\n             \"run_id\" = row_number())\n    \n    \n    #Add cumulative duration for each bout, resetting when cumulative downtime = 0\n    #set downtime_before to 0 for first row\n    rle_walkbouts$Downtime_before[1] <- 0\n    \n    rle_walkbouts$cumul_duration <- 0\n    \n    #set cumul_duration to Duration for first row\n    rle_walkbouts$cumul_duration[1] <- rle_walkbouts$Duration[1]\n    \n    #Create a counter for bouts - each new bout adds 1\n    rle_walkbouts$bout_count <- 1\n    \n    if(nrow(rle_walkbouts) >= 2){\n      for(ii in 2:nrow(rle_walkbouts)){\n      \n        rle_walkbouts$cumul_duration[ii] <- ifelse(rle_walkbouts$Downtime_before[ii] > 120,\n                                                rle_walkbouts$Duration[ii],\n                                                rle_walkbouts$Duration[ii] + rle_walkbouts$cumul_duration[ii - 1])\n      \n        rle_walkbouts$bout_count[ii] <- ifelse(rle_walkbouts$Downtime_before[ii] > 120,\n                                            rle_walkbouts$bout_count[ii - 1] + 1,\n                                            rle_walkbouts$bout_count[ii - 1])\n      \n            }\n          }\n          \n    \n    \n    time2 <- Sys.time()\n    \n    \n    potential_bouts <- rle_walkbouts %>%\n      group_by(bout_count) %>%\n      summarise(\"Begin\" = seconds_to_period(min(Time_begin)),\n                \"End\" = seconds_to_period(max(Time_end)),\n                \"Sum_Duration\" = sum(Duration),\n                \"Date\" = Date)\n    \n    valid_bouts_df <- potential_bouts %>%\n      filter(Sum_Duration >= 300) %>%\n      mutate(\"idno\" = id) %>%\n      select(Sum_Duration, idno, Begin, End, Date)\n    \n    # all_bouts_df <- tibble(\"Sum_Duration\" = NA,\n    #                        \"idno\" = NA,\n    #                        \"Date\" = NA,\n    #                        \"Time_Begin\" = NA,\n    #                        \"Time_End\" = NA)\n    \n    \n    time2 <- Sys.time()\n    \n    elapsed <- time2 - time1\n    \n    #add to bout level data set\n    all_bouts_df <- all_bouts_df %>%\n      bind_rows(valid_bouts_df)\n    \n    #create individual person level data\n    valid_bouts_total <- valid_bouts_df %>%\n      group_by(idno) %>%\n      summarise(\"N_Bouts\" = nrow(.)) %>%\n      mutate(\"Rows\" = nrow(data3),\n             \"Wear_Time_Seconds\" = nrow(data3) * 30,\n             \"Wear_Time_HMS\" = seconds_to_period(Wear_Time_Seconds),\n             \"Run_Time\" = elapsed,\n             \"Valid_Days\" = nrow(valid_dates))\n    \n    #add to person level data set\n    bouts_person_df <- bouts_person_df %>%\n      bind_rows(valid_bouts_total)\n    \n        } #closing if statment (length(rle500$values) > 1)\n    \n    #logic for entries with insufficient walk time to process\n    if(length(rle_over500$values) <= 1){ \n      time2 <- Sys.time() \n      \n      elapsed <- time2 - time1\n      \n      bouts_person_temp <- tibble(\"idno\" = id,\n                                  \"N_Bouts\" = 0,\n                                  \"Rows\" = nrow(data3),\n                                  \"Wear_Time_Seconds\" = nrow(data3) * 30,\n                                  \"Wear_Time_HMS\" = seconds_to_period(Wear_Time_Seconds),\n                                  \"Run_Time\" = elapsed,\n                                  \"Valid_Days\" = nrow(valid_dates))\n      \n      bouts_person_df <- bouts_person_df %>%\n        bind_rows(bouts_person_temp)\n      \n       }\n    \n      } #end if statement for ncols\n    \n    } #end for loop - individual csv processing\n\n  # save(bouts_person_df, all_bouts_df, file = here(\"data\", \"20210314-prelim_results.rda\"))\n  \n  #create output\n  save(bouts_person_df, all_bouts_df, file = out_file)\n  \n  if(return_df == T){\n    assign(\"bouts_person_df\", bouts_person_df, envir = .GlobalEnv)\n    \n    assign(\"all_bouts_df\", all_bouts_df, envir = .GlobalEnv)\n  }\n\n} #end function\n\n",
    "created" : 1644454627722.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "566343219",
    "id" : "956BD6FD",
    "lastKnownWriteTime" : 1632269310,
    "last_content_update" : 1632269310,
    "path" : "~/Desktop/retrieved_backup/epiProject/walk_bout/walk_bout_v0.0.2/make_package/rwalkabout/R/Bout-Function.R",
    "project_path" : "R/Bout-Function.R",
    "properties" : {
        "marks" : "<:0,0\n>:0,0"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}